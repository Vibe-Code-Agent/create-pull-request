name: üîç CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    # Run weekly security audits on Sundays at 2 AM UTC
    - cron: "0 2 * * 0"

# Cancel previous runs when a new commit is pushed to the same branch or PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Security checks - runs first (required)
  security:
    runs-on: ubuntu-latest
    steps:
      - name: Check if run was cancelled
        run: |
          echo "üîç Security Job - CI Run Information:"
          echo "Workflow: ${{ github.workflow }}"
          echo "Ref: ${{ github.ref }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Event: ${{ github.event_name }}"
          echo "Run ID: ${{ github.run_id }}"
          echo ""
          echo "‚úÖ Security job proceeding (previous runs cancelled if any)"

      - name: üîç Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: üì¶ Install dependencies
        run: npm ci

      - name: üîí Run security audit
        run: npm audit --audit-level=moderate

      - name: üîç Check for known vulnerabilities
        run: |
          echo "üîç Checking for security vulnerabilities..."
          npm audit --audit-level=high --json > audit-results.json || true

          # Check if there are high or critical vulnerabilities
          if [ -f "audit-results.json" ]; then
            HIGH_VULNS=$(cat audit-results.json | jq '.metadata.vulnerabilities.high // 0')
            CRITICAL_VULNS=$(cat audit-results.json | jq '.metadata.vulnerabilities.critical // 0')
            
            echo "üìä Security Audit Results:"
            echo "  High vulnerabilities: $HIGH_VULNS"
            echo "  Critical vulnerabilities: $CRITICAL_VULNS"
            
            if [ "$CRITICAL_VULNS" -gt 0 ]; then
              echo "‚ùå Critical vulnerabilities found! Please fix them before proceeding."
              exit 1
            elif [ "$HIGH_VULNS" -gt 0 ]; then
              echo "‚ö†Ô∏è High vulnerabilities found. Consider fixing them."
            else
              echo "‚úÖ No critical or high vulnerabilities found."
            fi
          fi

  # Code quality analysis - runs after security (required)
  code-quality:
    runs-on: ubuntu-latest
    needs: security
    steps:
      - name: üîç Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: üì¶ Cache analysis results
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            .eslintcache
            coverage
          key: code-quality-${{ runner.os }}-${{ hashFiles('src/**/*', '.eslintrc.*', 'tsconfig.json') }}
          restore-keys: |
            code-quality-${{ runner.os }}-

      - name: üì¶ Install dependencies
        run: npm ci

      - name: üìä Code complexity analysis
        run: |
          echo "üìä Analyzing code complexity..."

          # Simple complexity check using find and wc
          TOTAL_LINES=$(find src -name "*.ts" -exec wc -l {} + | tail -1 | awk '{print $1}')
          FILE_COUNT=$(find src -name "*.ts" | wc -l)

          if [ "$FILE_COUNT" -gt 0 ]; then
            AVG_LINES=$((TOTAL_LINES / FILE_COUNT))
            echo "üìà Code statistics:"
            echo "   Total files: $FILE_COUNT"
            echo "   Total lines: $TOTAL_LINES"
            echo "   Average lines per file: $AVG_LINES"
            
            if [ "$AVG_LINES" -gt 300 ]; then
              echo "‚ö†Ô∏è Average file size is quite large - consider refactoring"
            else
              echo "‚úÖ File sizes look reasonable"
            fi
          fi

      - name: üîç Dead code detection
        run: |
          echo "üîç Checking for potential dead code..."

          # Check for TODO/FIXME comments
          TODO_COUNT=$(find src -name "*.ts" -exec grep -l "TODO\|FIXME\|XXX" {} + | wc -l)
          if [ "$TODO_COUNT" -gt 0 ]; then
            echo "üìù Found $TODO_COUNT files with TODO/FIXME comments"
            find src -name "*.ts" -exec grep -Hn "TODO\|FIXME\|XXX" {} +
          else
            echo "‚úÖ No TODO/FIXME comments found"
          fi

  # Validate code quality on all pushes and PRs - runs after security and code-quality
  validate:
    runs-on: ubuntu-latest
    needs: [security, code-quality]

    strategy:
      matrix:
        node-version: [18, 20, 22] # Test multiple Node.js versions

    steps:
      - name: Check if run was cancelled
        run: |
          echo "üîç CI Run Information:"
          echo "Workflow: ${{ github.workflow }}"
          echo "Ref: ${{ github.ref }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Event: ${{ github.event_name }}"
          echo "Run ID: ${{ github.run_id }}"
          echo ""
          echo "‚úÖ This run is proceeding (previous runs cancelled if any)"
      - name: üîç Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: "npm"

      - name: üì¶ Cache build artifacts
        uses: actions/cache@v4
        with:
          path: |
            lib
            *.tsbuildinfo
          key: build-${{ runner.os }}-node${{ matrix.node-version }}-${{ hashFiles('src/**/*', 'tsconfig.json') }}
          restore-keys: |
            build-${{ runner.os }}-node${{ matrix.node-version }}-
            build-${{ runner.os }}-

      - name: üì¶ Install dependencies
        run: npm ci

      - name: üîç Check package integrity
        run: |
          # Verify package-lock.json is in sync
          npm ci --dry-run

          # Check for security issues in dependencies
          npm audit --audit-level=moderate
        continue-on-error: ${{ matrix.node-version != 20 }} # Only fail on primary version

      - name: üìù Run ESLint
        run: npm run lint

      - name: üèóÔ∏è Build TypeScript
        run: npm run build

      - name: üß™ Run tests with coverage
        run: npm test -- --coverage --watchAll=false

      - name: üìä Upload coverage artifacts
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-${{ matrix.node-version }}
          path: coverage/
          retention-days: 30

      - name: üìä Check build artifacts
        run: |
          echo "üîç Checking build artifacts..."

          # Verify main entry point exists
          if [ ! -f "lib/index.js" ]; then
            echo "‚ùå Main entry point missing!"
            exit 1
          fi

          # Verify CLI binary exists and is executable
          if [ ! -f "bin/create-pr.js" ]; then
            echo "‚ùå CLI binary missing!"
            exit 1
          fi

          if [ ! -x "bin/create-pr.js" ]; then
            echo "‚ùå CLI binary not executable!"
            exit 1
          fi

          # Check TypeScript declarations
          if [ ! -f "lib/index.d.ts" ]; then
            echo "‚ùå TypeScript declarations missing!"
            exit 1
          fi

          echo "‚úÖ All build artifacts present and valid"

      - name: üîç Package validation
        run: |
          echo "üîç Validating package.json..."

          # Check required fields
          node -e "
            const pkg = require('./package.json');
            const required = ['name', 'version', 'description', 'main', 'bin', 'license'];
            const missing = required.filter(field => !pkg[field]);
            if (missing.length > 0) {
              console.error('‚ùå Missing required fields:', missing.join(', '));
              process.exit(1);
            }
            console.log('‚úÖ All required package.json fields present');
          "

          # Validate semantic versioning
          node -e "
            const pkg = require('./package.json');
            const semverRegex = /^\\d+\\.\\d+\\.\\d+/;
            if (!semverRegex.test(pkg.version)) {
              console.error('‚ùå Invalid version format:', pkg.version);
              process.exit(1);
            }
            console.log('‚úÖ Version format valid:', pkg.version);
          "

      - name: üß™ Test CLI functionality (smoke test)
        run: |
          echo "üß™ Testing CLI functionality..."

          # Make binary executable (in case git doesn't preserve it)
          chmod +x bin/create-pr.js

          # Test help command
          node bin/create-pr.js --help > /dev/null
          if [ $? -eq 0 ]; then
            echo "‚úÖ CLI help command works"
          else
            echo "‚ùå CLI help command failed"
            exit 1
          fi

          # Test config command
          node bin/create-pr.js config > /dev/null
          if [ $? -eq 0 ]; then
            echo "‚úÖ CLI config command works"
          else
            echo "‚ùå CLI config command failed"
            exit 1
          fi

      - name: üì¶ Test packaging
        if: matrix.node-version == 20 # Only test on primary version
        run: |
          echo "üì¶ Testing npm pack..."

          # Create pack output in temp location
          PACK_OUTPUT=$(mktemp)
          npm pack --dry-run > "$PACK_OUTPUT" 2>&1

          echo "üìã Package contents:"
          cat "$PACK_OUTPUT"
          echo ""

          # Check if essential files are included
          if ! grep -q "lib/" "$PACK_OUTPUT"; then
            echo "‚ùå Build artifacts not included in package"
            cat "$PACK_OUTPUT"
            exit 1
          fi

          if ! grep -q "bin/" "$PACK_OUTPUT"; then
            echo "‚ùå CLI binary not included in package"
            cat "$PACK_OUTPUT"
            exit 1
          fi

          if ! grep -q "README.md" "$PACK_OUTPUT"; then
            echo "‚ùå README not included in package"
            cat "$PACK_OUTPUT"
            exit 1
          fi

          echo "‚úÖ Package contents validated"

          # Check package size
          TARBALL=$(npm pack --silent)
          PACKAGE_SIZE=$(ls -la "$TARBALL" | awk '{print $5}')
          echo "üì¶ Package size: $PACKAGE_SIZE bytes"

          # Clean up tarball
          rm -f "$TARBALL"
          rm -f "$PACK_OUTPUT"

          # Warn if package is too large (>5MB)
          if [ "$PACKAGE_SIZE" -gt 5242880 ]; then
            echo "‚ö†Ô∏è Package size is quite large (>5MB)"
          fi

  # Compatibility testing - runs only when all validation jobs pass
  compatibility:
    runs-on: ubuntu-latest
    needs: [security, code-quality, validate]
    if: |
      needs.security.result == 'success' && 
      needs.code-quality.result == 'success' && 
      needs.validate.result == 'success'
    steps:
      - name: Check if run was cancelled
        run: |
          echo "üîç Compatibility Job - CI Run Information:"
          echo "Workflow: ${{ github.workflow }}"
          echo "Ref: ${{ github.ref }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Event: ${{ github.event_name }}"
          echo "Run ID: ${{ github.run_id }}"
          echo ""
          echo "‚úÖ Compatibility job proceeding - all validation jobs passed successfully"
          echo "üìã Dependencies: security ‚úÖ, code-quality ‚úÖ, validate ‚úÖ"

      - name: üîç Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: üì¶ Cache security tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            /tmp/license-checker-*
            audit-report.json
          key: security-tools-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            security-tools-${{ runner.os }}-

      - name: üì¶ Install dependencies
        run: npm ci

      - name: üîí Security audit
        run: |
          echo "üîí Running security audit..."
          npm audit --audit-level=moderate

          # Generate audit report
          npm audit --json > audit-report.json || true

          # Check for high/critical issues
          HIGH_ISSUES=$(cat audit-report.json | jq '.metadata.vulnerabilities.high // 0')
          CRITICAL_ISSUES=$(cat audit-report.json | jq '.metadata.vulnerabilities.critical // 0')

          echo "Security summary:"
          echo "  High issues: $HIGH_ISSUES"
          echo "  Critical issues: $CRITICAL_ISSUES"

          if [ "$CRITICAL_ISSUES" -gt 0 ]; then
            echo "‚ùå Critical security issues found!"
            exit 1
          elif [ "$HIGH_ISSUES" -gt 0 ]; then
            echo "‚ö†Ô∏è High security issues found - review recommended"
          else
            echo "‚úÖ No high or critical security issues"
          fi

      - name: üîç License check
        run: |
          echo "üîç Checking dependency licenses..."
          # This requires license-checker to be installed
          npx license-checker --summary || echo "License check skipped - license-checker not available"

  # Report results
  report:
    runs-on: ubuntu-latest
    needs: [validate, security, code-quality, compatibility]
    if: always()

    steps:
      - name: üîç Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: üì¶ Cache analysis results
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            .eslintcache
            coverage
          key: code-quality-${{ runner.os }}-${{ hashFiles('src/**/*', '.eslintrc.*', 'tsconfig.json') }}
          restore-keys: |
            code-quality-${{ runner.os }}-

      - name: üì¶ Install dependencies
        run: npm ci

      - name: üìä Code complexity analysis
        run: |
          echo "üìä Analyzing code complexity..."

          # Simple complexity check using find and wc
          TOTAL_LINES=$(find src -name "*.ts" -exec wc -l {} + | tail -1 | awk '{print $1}')
          FILE_COUNT=$(find src -name "*.ts" | wc -l)

          if [ "$FILE_COUNT" -gt 0 ]; then
            AVG_LINES=$((TOTAL_LINES / FILE_COUNT))
            echo "üìà Code statistics:"
            echo "   Total files: $FILE_COUNT"
            echo "   Total lines: $TOTAL_LINES"
            echo "   Average lines per file: $AVG_LINES"
            
            if [ "$AVG_LINES" -gt 300 ]; then
              echo "‚ö†Ô∏è Average file size is quite large - consider refactoring"
            else
              echo "‚úÖ File sizes look reasonable"
            fi
          fi

      - name: üîç Dead code detection
        run: |
          echo "üîç Checking for potential dead code..."

          # Check for TODO/FIXME comments
          TODO_COUNT=$(find src -name "*.ts" -exec grep -l "TODO\|FIXME\|XXX" {} + | wc -l)
          if [ "$TODO_COUNT" -gt 0 ]; then
            echo "üìù Found $TODO_COUNT files with TODO/FIXME comments"
            find src -name "*.ts" -exec grep -Hn "TODO\|FIXME\|XXX" {} +
          else
            echo "‚úÖ No TODO/FIXME comments found"
          fi

  # SonarCloud Analysis - runs after all CI jobs pass
  sonarcloud:
    name: SonarCloud Analysis
    runs-on: ubuntu-latest
    needs: [validate, security, code-quality, compatibility, report]
    if: |
      github.actor != 'dependabot[bot]' &&
      needs.validate.result == 'success' && 
      needs.security.result == 'success' && 
      needs.code-quality.result == 'success' && 
      needs.compatibility.result == 'success' &&
      needs.report.result == 'success'
    outputs:
      quality_gate_status: ${{ steps.quality-gate.outputs.quality_gate_status }}
      quality_gate_result: ${{ steps.quality-gate.outputs.quality_gate_result }}
      bugs: ${{ steps.sonar-metrics.outputs.bugs }}
      vulnerabilities: ${{ steps.sonar-metrics.outputs.vulnerabilities }}
      security_hotspots: ${{ steps.sonar-metrics.outputs.security_hotspots }}
      code_smells: ${{ steps.sonar-metrics.outputs.code_smells }}
      coverage: ${{ steps.sonar-metrics.outputs.coverage }}
      duplicated_lines: ${{ steps.sonar-metrics.outputs.duplicated_lines }}
      lines_of_code: ${{ steps.sonar-metrics.outputs.lines_of_code }}

    steps:
      - name: Show trigger information
        run: |
          echo "üîç SonarCloud Analysis Information"
          echo "=========================================="
          echo "Event: ${{ github.event_name }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "PR Number: ${{ github.event.pull_request.number }}"
            echo "PR Head: ${{ github.event.pull_request.head.ref }}"
            echo "PR Base: ${{ github.event.pull_request.base.ref }}"
          fi
          echo ""

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Full git history is needed for SonarCloud
          fetch-depth: 0

      - name: Download coverage artifacts from CI
        uses: actions/download-artifact@v4
        with:
          name: coverage-report-20
          path: coverage/
        continue-on-error: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build

      - name: Generate coverage if artifact not found
        run: |
          if [ ! -f "coverage/lcov.info" ]; then
            echo "‚ö†Ô∏è Coverage artifact not found, generating coverage locally..."
            npm test -- --coverage --watchAll=false
            echo "‚úÖ Coverage generated locally"
          else
            echo "‚úÖ Using coverage from CI artifact"
          fi

      - name: Verify coverage file exists
        run: |
          if [ -f "coverage/lcov.info" ]; then
            echo "‚úÖ Coverage file found: coverage/lcov.info"
            echo "Coverage file size: $(wc -l < coverage/lcov.info) lines"
          else
            echo "‚ùå Coverage file not found: coverage/lcov.info"
            echo "Available files in coverage directory:"
            ls -la coverage/ || echo "Coverage directory does not exist"
            exit 1
          fi

      - name: Prepare SonarCloud arguments
        id: sonar-args
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"

          # Get SonarCloud configuration from sonar-project.properties
          echo "üîß Reading SonarCloud configuration..."

          if [ -f "sonar-project.properties" ]; then
            SONAR_PROJECT_KEY=$(grep "^sonar.projectKey=" sonar-project.properties | cut -d'=' -f2 | tr -d ' ')
            SONAR_ORGANIZATION=$(grep "^sonar.organization=" sonar-project.properties | cut -d'=' -f2 | tr -d ' ')
            echo "‚úÖ Found sonar-project.properties"
            echo "  Project Key: $SONAR_PROJECT_KEY"
            echo "  Organization: $SONAR_ORGANIZATION"
          else
            SONAR_PROJECT_KEY="${{ github.event.repository.name }}"
            SONAR_ORGANIZATION="${{ github.repository_owner }}"
            echo "‚ö†Ô∏è Using GitHub context fallback"
          fi

          # Base arguments
          BASE_ARGS="-Dsonar.projectKey=$SONAR_PROJECT_KEY -Dsonar.organization=$SONAR_ORGANIZATION"

          if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "" ]; then
            # PR-specific analysis
            echo "üîç Configuring for PR #$PR_NUMBER analysis"
            PR_HEAD="${{ github.event.pull_request.head.ref }}"
            PR_BASE="${{ github.event.pull_request.base.ref }}"
            
            echo "üìã PR Details:"
            echo "  PR Number: $PR_NUMBER"
            echo "  Head branch: $PR_HEAD"
            echo "  Base branch: $PR_BASE"
            
            PR_ARGS="-Dsonar.pullrequest.key=$PR_NUMBER -Dsonar.pullrequest.branch=$PR_HEAD -Dsonar.pullrequest.base=$PR_BASE"
            SONAR_ARGS="$BASE_ARGS $PR_ARGS"
            echo "‚úÖ Using PR-specific analysis mode"
          else
            # Full project analysis
            echo "üîç Using full project analysis"
            SONAR_ARGS="$BASE_ARGS"
          fi

          echo "sonar_args=$SONAR_ARGS" >> $GITHUB_OUTPUT
          echo "üìã SonarCloud arguments: $SONAR_ARGS"

      - name: SonarCloud Scan
        id: sonarcloud-scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: ${{ steps.sonar-args.outputs.sonar_args }}
        continue-on-error: true

      - name: Wait for SonarCloud Quality Gate
        id: quality-gate
        run: |
          echo "‚è≥ Polling SonarCloud for Quality Gate result..."

          PR_NUMBER="${{ github.event.pull_request.number }}"

          if [ -f "sonar-project.properties" ]; then
            SONAR_PROJECT_KEY=$(grep "^sonar.projectKey=" sonar-project.properties | cut -d'=' -f2 | tr -d ' ')
          else
            SONAR_PROJECT_KEY="${{ github.event.repository.name }}"
          fi

          # Polling configuration
          MAX_ATTEMPTS=30
          POLL_INTERVAL=10
          ATTEMPT=0
          QUALITY_GATE_STATUS="PENDING"

          # Function to fetch Quality Gate status
          fetch_quality_gate() {
            local pr_num="$1"
            local project_key="$2"
            
            if [ -n "$pr_num" ] && [ "$pr_num" != "" ]; then
              # Try PR-specific endpoint first
              local response=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
                "https://sonarcloud.io/api/qualitygates/project_status?projectKey=$project_key&pullRequest=$pr_num" 2>/dev/null || echo "")
              
              if [ -n "$response" ] && echo "$response" | jq -e '.projectStatus.status' > /dev/null 2>&1; then
                echo "$response" | jq -r '.projectStatus.status'
                return 0
              fi
            fi
            
            # Fallback to project-level status
            local response=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
              "https://sonarcloud.io/api/qualitygates/project_status?projectKey=$project_key" 2>/dev/null || echo "")
            
            if [ -n "$response" ] && echo "$response" | jq -e '.projectStatus.status' > /dev/null 2>&1; then
              echo "$response" | jq -r '.projectStatus.status'
              return 0
            fi
            
            echo "PENDING"
            return 1
          }

          # Poll until we get a non-PENDING status or reach max attempts
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            
            echo "üìä Attempt $ATTEMPT/$MAX_ATTEMPTS - Checking Quality Gate status..."
            
            QUALITY_GATE_STATUS=$(fetch_quality_gate "$PR_NUMBER" "$SONAR_PROJECT_KEY")
            
            echo "   Status: $QUALITY_GATE_STATUS"
            
            # If status is not PENDING or NONE, we have a result
            if [ "$QUALITY_GATE_STATUS" != "PENDING" ] && [ "$QUALITY_GATE_STATUS" != "NONE" ] && [ -n "$QUALITY_GATE_STATUS" ]; then
              echo "‚úÖ Quality Gate result received after $((ATTEMPT * POLL_INTERVAL)) seconds"
              break
            fi
            
            # Don't sleep on the last attempt
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              echo "   ‚è≥ Waiting ${POLL_INTERVAL}s before next check..."
              sleep $POLL_INTERVAL
            fi
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ] && [ "$QUALITY_GATE_STATUS" = "PENDING" ]; then
            echo "‚ö†Ô∏è Quality Gate still pending after $((MAX_ATTEMPTS * POLL_INTERVAL)) seconds"
            echo "   This might indicate SonarCloud is taking longer than usual to process"
          fi

          echo "quality_gate_status=$QUALITY_GATE_STATUS" >> $GITHUB_OUTPUT
          echo "üîç Final Quality Gate Status: $QUALITY_GATE_STATUS"

          if [ "$QUALITY_GATE_STATUS" = "OK" ]; then
            echo "‚úÖ Quality Gate passed!"
            echo "quality_gate_result=‚úÖ **Quality Gate: PASSED**" >> $GITHUB_OUTPUT
          elif [ "$QUALITY_GATE_STATUS" = "WARN" ]; then
            echo "‚ö†Ô∏è Quality Gate passed with warnings"
            echo "quality_gate_result=‚ö†Ô∏è **Quality Gate: PASSED with warnings**" >> $GITHUB_OUTPUT
          elif [ "$QUALITY_GATE_STATUS" = "PENDING" ] || [ "$QUALITY_GATE_STATUS" = "NONE" ]; then
            echo "‚è≥ Quality Gate is still processing"
            echo "quality_gate_result=‚è≥ **Quality Gate: PENDING** - Analysis may still be processing" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Quality Gate failed"
            echo "quality_gate_result=‚ùå **Quality Gate: FAILED**" >> $GITHUB_OUTPUT
          fi

      - name: Get SonarCloud metrics
        id: sonar-metrics
        run: |
          echo "üìä Fetching SonarCloud metrics..."

          PR_NUMBER="${{ github.event.pull_request.number }}"

          if [ -f "sonar-project.properties" ]; then
            SONAR_PROJECT_KEY=$(grep "^sonar.projectKey=" sonar-project.properties | cut -d'=' -f2 | tr -d ' ')
          else
            SONAR_PROJECT_KEY="${{ github.event.repository.name }}"
          fi

          METRICS=""

          if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "" ]; then
            echo "üéØ Fetching metrics for PR #$PR_NUMBER..."
            METRICS=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
              "https://sonarcloud.io/api/measures/component?component=$SONAR_PROJECT_KEY&pullRequest=$PR_NUMBER&metricKeys=bugs,vulnerabilities,security_hotspots,code_smells,coverage,duplicated_lines_density,ncloc" 2>/dev/null || echo "")
            
            if [ -z "$METRICS" ] || ! echo "$METRICS" | jq -e '.component' > /dev/null 2>&1; then
              echo "‚ö†Ô∏è PR metrics not available, using main project metrics"
              METRICS=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
                "https://sonarcloud.io/api/measures/component?component=$SONAR_PROJECT_KEY&metricKeys=bugs,vulnerabilities,security_hotspots,code_smells,coverage,duplicated_lines_density,ncloc")
            fi
          else
            echo "üìä Fetching metrics for main project..."
            METRICS=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
              "https://sonarcloud.io/api/measures/component?component=$SONAR_PROJECT_KEY&metricKeys=bugs,vulnerabilities,security_hotspots,code_smells,coverage,duplicated_lines_density,ncloc")
          fi

          if [ -n "$METRICS" ] && echo "$METRICS" | jq -e '.component.measures' > /dev/null 2>&1; then
            BUGS=$(echo "$METRICS" | jq -r '.component.measures[]? | select(.metric=="bugs") | .value // "0"')
            VULNERABILITIES=$(echo "$METRICS" | jq -r '.component.measures[]? | select(.metric=="vulnerabilities") | .value // "0"')
            SECURITY_HOTSPOTS=$(echo "$METRICS" | jq -r '.component.measures[]? | select(.metric=="security_hotspots") | .value // "0"')
            CODE_SMELLS=$(echo "$METRICS" | jq -r '.component.measures[]? | select(.metric=="code_smells") | .value // "0"')
            COVERAGE=$(echo "$METRICS" | jq -r '.component.measures[]? | select(.metric=="coverage") | .value // "0"')
            DUPLICATED_LINES=$(echo "$METRICS" | jq -r '.component.measures[]? | select(.metric=="duplicated_lines_density") | .value // "0"')
            LINES_OF_CODE=$(echo "$METRICS" | jq -r '.component.measures[]? | select(.metric=="ncloc") | .value // "0"')
          else
            BUGS="0"
            VULNERABILITIES="0"
            SECURITY_HOTSPOTS="0"
            CODE_SMELLS="0"
            COVERAGE="0"
            DUPLICATED_LINES="0"
            LINES_OF_CODE="0"
          fi

          echo "üìã Metrics:"
          echo "  Bugs: $BUGS"
          echo "  Vulnerabilities: $VULNERABILITIES"
          echo "  Security Hotspots: $SECURITY_HOTSPOTS"
          echo "  Code Smells: $CODE_SMELLS"
          echo "  Coverage: $COVERAGE%"

          echo "bugs=$BUGS" >> $GITHUB_OUTPUT
          echo "vulnerabilities=$VULNERABILITIES" >> $GITHUB_OUTPUT
          echo "security_hotspots=$SECURITY_HOTSPOTS" >> $GITHUB_OUTPUT
          echo "code_smells=$CODE_SMELLS" >> $GITHUB_OUTPUT
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
          echo "duplicated_lines=$DUPLICATED_LINES" >> $GITHUB_OUTPUT
          echo "lines_of_code=$LINES_OF_CODE" >> $GITHUB_OUTPUT

  # Quality Gate Check - final validation
  quality-gate:
    name: Quality Gate Check
    runs-on: ubuntu-latest
    needs: sonarcloud
    if: always() && needs.sonarcloud.result != 'cancelled' && needs.sonarcloud.result != 'skipped'

    steps:
      - name: Quality Gate Status Summary
        run: |
          QUALITY_GATE_STATUS="${{ needs.sonarcloud.outputs.quality_gate_status }}"
          SONARCLOUD_RESULT="${{ needs.sonarcloud.result }}"

          echo "üîç SonarCloud job result: $SONARCLOUD_RESULT"
          echo "üîç Quality Gate status: $QUALITY_GATE_STATUS"

          if [ "$SONARCLOUD_RESULT" = "failure" ]; then
            echo "‚ùå SonarCloud scan encountered issues, but workflow will continue"
          elif [ "$QUALITY_GATE_STATUS" = "ERROR" ] || [ "$QUALITY_GATE_STATUS" = "FAILED" ]; then
            echo "‚ùå Quality Gate failed, but workflow will continue"
          elif [ "$QUALITY_GATE_STATUS" = "WARN" ]; then
            echo "‚ö†Ô∏è Quality Gate passed with warnings"
          else
            echo "‚úÖ Quality Gate passed!"
          fi

          echo "üìä SonarCloud analysis completed"
          echo "üîó View report: https://sonarcloud.io/project/overview?id=create-pull-request"
